package io.otly.core.gwt.shared.internal;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import io.otly.spi.gwt.shared.DocumentModel;
import io.otly.spi.gwt.shared.DocumentModelChangeListener;
import io.otly.spi.gwt.shared.Operation;
import io.otly.spi.gwt.shared.OperationPair;
import io.otly.spi.gwt.shared.Transformer;

/**
 * JupiterNode.
 *
 * This is an implementation of the Jupiter algorithm as explained in the Jupiter paper
 * (http://dl.acm.org/citation.cfm?id=215706)
 *
 * @version $Id$
 */
public abstract class JupiterNode implements DocumentModelChangeListener
{
    /**
     * The node id.
     */
    protected final String id;

    /**
     * The documentModel model associated to the node.
     */
    protected final DocumentModel documentModel;

    /**
     * List of sent messages that are not yet acknowledged. They are needed in order to fixup incoming messages. See
     * Figure 7 of Jupiter paper.
     */
    protected final List<Message> unacknowledgedMessages;

    /**
     * The priority to be used when transforming conflicting operations. It is used when two nodes interacts, to define
     * the same criteria for choosing which side always "wins" in case of conflict.
     */
    private final Transformer.Priority priority;

    /**
     * The number of messages generated by this node.
     */
    protected int generatedMessages;

    /**
     * The number of messages received from this node's peer.
     */
    protected int otherMessages;

    /**
     * @param id the node id.
     * @param documentModel the documentModel associated to the node.
     * @param priority the priority to be used when transforming conflicting operations.
     */
    public JupiterNode(String id, DocumentModel documentModel, Transformer.Priority priority)
    {
        unacknowledgedMessages = new ArrayList<Message>();

        this.id = id;
        this.documentModel = documentModel;
        this.documentModel.addDocumentModelChangeListener(this);
        this.priority = priority;
    }

    /**
     * This is the "Generate(op)" method in Figure 6 of the Jupiter paper. We only have the line corresponding to the
     * "apply op locally" because when the operation is applied, we'll be notified via the onDocumentModelChange method
     * (where the remaining logic is)
     *
     * @param op the operation to be applied.
     */
    public synchronized void generate(Operation op)
    {
        documentModel.apply(op);
    }

    /**
     * This method is called when the associated documentModel is modified by the application of an operation. Here we create
     * a message with the current state of the node and send the operation to the other party so that it can take it
     * into account.
     *
     * This method implements almost fully the "Generate(op)" method in Figure 6 of the Jupiter paper. Only the "apply
     * op locally" is omitted because when we get here, the operation has already applied.
     *
     * @param op the applied operation.
     */
    @Override public synchronized void onDocumentModelChange(Operation op)
    {
        Message message = new Message();
        message.nodeId = id;
        message.generatedMessages = generatedMessages;
        message.otherMessages = otherMessages;
        message.op = op;
        unacknowledgedMessages.add(message);

        send(message);

        generatedMessages++;
    }

    /**
     * This is the method "Receive(msg)" in the Jupiter paper. It is used to receive messages from the node's peer.
     *
     * @param message a data structure containing the operation and the current state (number of generated and received
     * messages) of the node.
     */
    public synchronized void receive(Message message)
    {
        /* Discard acknowledged messages */
        Iterator<Message> iterator = unacknowledgedMessages.iterator();
        while (iterator.hasNext()) {
            Message current = iterator.next();
            if (current.generatedMessages < message.otherMessages) {
                iterator.remove();
            }
        }

        /* This is the invariant */
        if (message.generatedMessages != otherMessages) {
            throw new RuntimeException("Inconsistent state");
        }

        /* Transform the incoming message against the ones that have been already applied locally.
        (see Figure 7 of the Jupiter paper) */
        Transformer transformer = documentModel.getTransformer();

        /* Original sent operation. This will be transformed repeatedly against all non-yet-acknowledged operations. */
        Operation op = message.op;

        for (int i = 0; i < unacknowledgedMessages.size(); i++) {
            Message currentUnacknowledgedMessage = unacknowledgedMessages.get(i);
            OperationPair operationPair =
                    transformer.transform(currentUnacknowledgedMessage.op, op, priority);

            Message transformedUnacknowledgedMessage = new Message();
            transformedUnacknowledgedMessage.nodeId = currentUnacknowledgedMessage.nodeId;
            transformedUnacknowledgedMessage.generatedMessages = currentUnacknowledgedMessage.generatedMessages;
            transformedUnacknowledgedMessage.otherMessages = currentUnacknowledgedMessage.otherMessages + 1;
            transformedUnacknowledgedMessage.op =
                    operationPair.getLeft(); // Transformed unacknowledgedMessage[i] (left) operation.
            unacknowledgedMessages.set(i, transformedUnacknowledgedMessage);

            op = operationPair.getRight(); // Transformed received (right) operation.
        }

        /* Temporarily remove the listener in order to avoid to receive the modification event which will trigger a
        message sending. */
        documentModel.removeDocumentModelChangeListener(this);
        documentModel.apply(op);
        documentModel.addDocumentModelChangeListener(this);

        otherMessages++;
    }

    /**
     * Send a message containing an operation and the current state (number of generated and received messages) to the
     * other node.
     */
    abstract public void send(Message message);

    public DocumentModel getDocumentModel()
    {
        return documentModel;
    }

    public String getId()
    {
        return id;
    }

    /**
     * An internal class definition for sending an operation and the current state (number of generated and received
     * messages)
     */
    public static class Message
    {
        public String nodeId;

        public int generatedMessages;

        public int otherMessages;

        public Operation op;
    }
}
